<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Endless Runner</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Poppins', 'Arial', sans-serif;
            background-color: #111;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Bangers', cursive;
            letter-spacing: 2px;
        }
        .ui-element {
            pointer-events: auto;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: clamp(2em, 5vw, 3em);
            display: none;
        }
        #pause-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            cursor: pointer;
            background: #f39c12;
            border: 4px solid white;
            border-radius: 50%;
            box-shadow: 0 5px 0 #c0392b, inset 0 5px 10px rgba(255,255,255,0.5);
            transition: all 0.1s ease-in-out;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #pause-button:active {
            transform: translateY(5px);
            box-shadow: 0 0px 0 #c0392b, inset 0 3px 8px rgba(0,0,0,0.5);
        }
        #pause-button .icon {
            width: 50%;
            height: 50%;
            fill: white;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }
        #pause-button .play-icon {
            display: none; /* Hidden by default */
        }
        .overlay {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, rgba(29, 38, 113, 0.9), rgba(195, 55, 100, 0.9));
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 90%;
            width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .overlay h1 {
            font-size: clamp(3em, 10vw, 5em);
            margin: 0 0 20px 0;
        }
        .overlay p {
            font-size: clamp(1.5em, 4vw, 2em);
            margin: 10px 0;
            font-family: 'Poppins', sans-serif;
            letter-spacing: 0;
        }
        .overlay .start-button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: clamp(1.2em, 4vw, 1.6em);
            cursor: pointer;
            color: white;
            border: 4px solid #fff;
            border-radius: 50px;
            text-transform: uppercase;
            background: #27ae60;
            transition: all 0.15s ease-in-out;
            box-shadow: 0 6px 0 #16a085;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        .overlay .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 0 #16a085;
        }
        .overlay .start-button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #16a085;
        }
        .overlay .start-button .icon {
            width: 1.2em;
            height: 1.2em;
        }
        #start-screen .start-button {
             background: linear-gradient(45deg, #f39c12, #e74c3c);
             box-shadow: 0 6px 0 #c0392b;
        }
         #start-screen .start-button:hover {
            box-shadow: 0 8px 0 #c0392b;
        }
        #start-screen .start-button:active {
            box-shadow: 0 2px 0 #c0392b;
        }
        #start-screen {
            display: flex;
        }
        .instructions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            font-family: 'Poppins', sans-serif;
            letter-spacing: 0;
        }
        .instruction-category {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }
        .instruction-category h2 {
            margin-top: 0;
            font-size: clamp(1.2em, 4vw, 1.5em);
            border-bottom: 2px solid rgba(255,255,255,0.3);
            padding-bottom: 10px;
            font-family: 'Bangers', cursive;
            letter-spacing: 1px;
        }
        .control {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            flex-direction: column;
        }
        .control span {
            margin-top: 5px;
            font-size: clamp(0.9em, 2.5vw, 1em);
            font-weight: 600;
        }
        .icon {
            width: 40px;
            height: 40px;
            fill: white;
        }
        .key-icon {
            background: #34495e;
            border-radius: 8px;
            padding: 5px;
            border: 2px solid #bdc3c7;
            box-shadow: 0 3px 0 #7f8c8d;
        }
        .control-row {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        /* Pause & Countdown Screen Styles */
        #pause-screen {
            background: transparent;
            box-shadow: none;
        }
        #pause-screen h1 {
            font-size: clamp(5em, 20vw, 8em);
            text-shadow: 5px 5px 0px rgba(0,0,0,0.25);
        }
        #countdown-screen {
            background: transparent;
            box-shadow: none;
        }
        #countdown-number {
            font-size: clamp(8em, 35vw, 15em);
            text-shadow: 0 0 10px rgba(0,0,0,0.3), 0 0 20px rgba(0,0,0,0.3);
            opacity: 0;
        }
        #countdown-number.animate {
            animation: countdownZoom 1s ease-out forwards;
        }
        @keyframes countdownZoom {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        
        /* Game Over Screen Specific Styles */
        #game-over-screen {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
        }
        #game-over-screen h1 {
            font-size: clamp(4em, 15vw, 7em);
            text-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            transform: scale(0);
            opacity: 0;
        }
        #game-over-screen.active h1 {
            animation: gameOverBounce 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        #game-over-screen #final-score {
            opacity: 0;
            transform: translateY(20px);
        }
        #game-over-screen.active #final-score {
            animation: slideUpFadeIn 0.5s 0.3s forwards;
        }
        #game-over-screen .start-button {
             opacity: 0;
             transform: translateY(20px);
        }
        #game-over-screen.active .start-button {
            animation: slideUpFadeIn 0.5s 0.6s forwards;
        }

        @keyframes gameOverBounce {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.1); opacity: 1; }
            80% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes slideUpFadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui-container">
        <div id="score" class="ui-element">Score: 0</div>
        <button id="pause-button" class="ui-element">
            <svg class="icon pause-icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
            <svg class="icon play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
        </button>
        
        <div id="start-screen" class="overlay ui-element">
            <h1>Endless Runner</h1>
            <div class="instructions-grid">
                <div class="instruction-category">
                    <h2>Keyboard</h2>
                    <div class="control">
                        <svg class="icon key-icon" viewBox="0 0 24 24"><path d="M12 8l-6 6h12l-6-6z"></path></svg>
                        <span>Up</span>
                    </div>
                    <div class="control-row">
                        <div class="control">
                            <svg class="icon key-icon" viewBox="0 0 24 24"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"></path></svg>
                            <span>Left</span>
                        </div>
                        <div class="control">
                           <svg class="icon key-icon" viewBox="0 0 24 24"><path d="M12 16l6-6H6l6 6z"></path></svg>
                           <span>Down</span>
                        </div>
                        <div class="control">
                            <svg class="icon key-icon" viewBox="0 0 24 24"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"></path></svg>
                            <span>Right</span>
                        </div>
                    </div>
                </div>
                <div class="instruction-category">
                    <h2>Touchscreen</h2>
                     <div class="control">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M4 12h1.41l5.3-5.29 1.41 1.41-3.29 3.29H20v2H9.83l3.29 3.29-1.41 1.41L4 12z M12 4l1.41 1.41L8.83 10H20v4H8.83l4.58 4.59L12 20l-6-6 6-6z" transform="rotate(-90 12 12)"></path></svg>
                        <span>Swipe Up</span>
                    </div>
                     <div class="control">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M4 12h1.41l5.3-5.29 1.41 1.41-3.29 3.29H20v2H9.83l3.29 3.29-1.41 1.41L4 12z M12 4l1.41 1.41L8.83 10H20v4H8.83l4.58 4.59L12 20l-6-6 6-6z" transform="rotate(90 12 12)"></path></svg>
                        <span>Swipe Down</span>
                    </div>
                </div>
            </div>
            <button id="start-button" class="start-button">Start Game</button>
        </div>

        <div id="pause-screen" class="overlay ui-element">
            <h1>Paused</h1>
        </div>

        <div id="countdown-screen" class="overlay ui-element">
            <h1 id="countdown-number">3</h1>
        </div>
        
        <div id="game-over-screen" class="overlay ui-element">
            <h1>Game Over</h1>
            <p id="final-score">Your Score: 0</p>
            <button id="restart-button" class="start-button">
                <span>Try Again</span>
                <svg class="icon" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
            </button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 15, 120);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 12);
        camera.lookAt(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // --- LIGHTING & SUN ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const sunPosition = new THREE.Vector3(150, 75, -200);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.copy(sunPosition);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const sunGeo = new THREE.SphereGeometry(10, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffddaa, fog: false });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        sun.position.copy(sunPosition);
        scene.add(sun);


        // --- GAME VARIABLES ---
        const LANE_WIDTH = 5;
        const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const PLAYER_SPEED = 0.2;
        let gameSpeed = 0.3;
        let score = 0;
        let isGameOver = false;
        let isPaused = false;

        let player, playerCollider, playerModel;
        let leftArm, rightArm, leftLeg, rightLeg;
        let currentLane = 1;
        let isJumping = false;
        let isRolling = false;
        let jumpVelocity = 0;
        const GRAVITY = -0.04;
        const JUMP_FORCE = 0.8;
        let rollTimeout;

        const trackSegments = [];
        const obstacles = [];
        const coins = [];
        const clouds = [];
        const trees = [];
        const buildings = [];
        const vehicles = [];
        const powerLines = [];
        const activeParticles = [];

        // --- UI ELEMENTS ---
        const scoreElement = document.getElementById('score');
        const pauseButton = document.getElementById('pause-button');
        const pauseIcon = pauseButton.querySelector('.pause-icon');
        const playIcon = pauseButton.querySelector('.play-icon');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const pauseScreen = document.getElementById('pause-screen');
        const countdownScreen = document.getElementById('countdown-screen');
        const countdownNumber = document.getElementById('countdown-number');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // --- PLAYER ---
        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff5733 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const limbGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);

            const torsoGeo = new THREE.CylinderGeometry(0.7, 0.4, 1.8, 16);
            const torso = new THREE.Mesh(torsoGeo, bodyMat);
            torso.position.y = 1.6;
            torso.castShadow = true;

            const headGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 2.7;
            head.castShadow = true;

            leftArm = new THREE.Mesh(limbGeo, skinMat);
            leftArm.position.set(-0.7, 2.2, 0);
            leftArm.castShadow = true;

            rightArm = new THREE.Mesh(limbGeo, skinMat);
            rightArm.position.set(0.7, 2.2, 0);
            rightArm.castShadow = true;

            leftLeg = new THREE.Mesh(limbGeo, skinMat);
            leftLeg.position.set(-0.3, 0.6, 0);
            leftLeg.castShadow = true;

            rightLeg = new THREE.Mesh(limbGeo, skinMat);
            rightLeg.position.set(0.3, 0.6, 0);
            rightLeg.castShadow = true;
            
            playerModel = new THREE.Group();
            playerModel.add(torso, head, leftArm, rightArm, leftLeg, rightLeg);
            playerGroup.add(playerModel);
            
            const colliderGeo = new THREE.BoxGeometry(1.5, 3.5, 1.5);
            const colliderMat = new THREE.MeshBasicMaterial({ visible: false, wireframe: true });
            playerCollider = new THREE.Mesh(colliderGeo, colliderMat);
            playerCollider.position.y = 1.75;
            playerGroup.add(playerCollider);

            playerGroup.position.y = 0;
            playerGroup.position.x = LANES[currentLane];
            return playerGroup;
        }

        // --- TRACK ---
        const groundColors = [0x5a5a5a, 0x555555];
        function createTrackSegment(positionZ, colorIndex) {
            const segment = new THREE.Group();
            const groundGeo = new THREE.PlaneGeometry(LANE_WIDTH * 4, 40);
            const groundMat = new THREE.MeshStandardMaterial({ color: groundColors[colorIndex % 2] });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            segment.add(ground);
            for (let i = -1; i <= 1; i++) {
                const railGeo = new THREE.BoxGeometry(0.2, 0.2, 40);
                const railMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const rail = new THREE.Mesh(railGeo, railMat);
                rail.position.set(LANES[1] + i * 2, 0.1, 0);
                rail.receiveShadow = true;
                segment.add(rail);
                const tieGeo = new THREE.BoxGeometry(2.5, 0.1, 0.3);
                const tieMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
                for (let j = 0; j < 10; j++) {
                    const tie = new THREE.Mesh(tieGeo, tieMat);
                    tie.position.set(LANES[1] + i * 2, 0.05, -18 + j * 4);
                    tie.receiveShadow = true;
                    segment.add(tie);
                }
            }
            segment.position.z = positionZ;
            scene.add(segment);
            trackSegments.push(segment);
            return segment;
        }

        // --- OBSTACLES & COINS ---
        function createObstacle(lane, type) {
            const obstacleGroup = new THREE.Group();
            let collider;
            if (type === 'barrier') {
                const barrierGeo = new THREE.BoxGeometry(LANE_WIDTH - 0.5, 2.5, 1);
                const barrierMat = new THREE.MeshStandardMaterial({ color: 0xc0392b });
                const barrier = new THREE.Mesh(barrierGeo, barrierMat);
                barrier.position.y = 1.25;
                barrier.castShadow = true;
                obstacleGroup.add(barrier);
                collider = new THREE.Box3().setFromObject(barrier);
            } else if (type === 'overhang') {
                const overhangGeo = new THREE.BoxGeometry(LANE_WIDTH - 0.5, 2, 1);
                const overhangMat = new THREE.MeshStandardMaterial({ color: 0x2980b9 });
                const overhang = new THREE.Mesh(overhangGeo, overhangMat);
                overhang.position.y = 4.5;
                overhang.castShadow = true;
                obstacleGroup.add(overhang);
                collider = new THREE.Box3().setFromObject(overhang);
            }
            obstacleGroup.position.x = LANES[lane];
            obstacleGroup.position.z = -100;
            const obstacle = { mesh: obstacleGroup, collider: collider, type: type };
            scene.add(obstacle.mesh);
            obstacles.push(obstacle);
        }
        function spawnObstacles() {
            const lanesToBlock = new Set();
            lanesToBlock.add(Math.floor(Math.random() * 3));
            if (Math.random() > 0.4) {
                 let secondLane = Math.floor(Math.random() * 3);
                 while(lanesToBlock.has(secondLane)) {
                    secondLane = Math.floor(Math.random() * 3);
                 }
                 lanesToBlock.add(secondLane);
            }
            lanesToBlock.forEach(lane => {
                const type = Math.random() > 0.5 ? 'barrier' : 'overhang';
                createObstacle(lane, type);
            });
        }
        function createCoin(lane, zOffset) {
            const coinGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.15, 16);
            const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xcc9900 });
            const coinMesh = new THREE.Mesh(coinGeo, coinMat);
            coinMesh.castShadow = true;
            const coin = {
                mesh: coinMesh,
                collider: new THREE.Box3().setFromObject(coinMesh),
                initialY: 2.5,
                bobOffset: Math.random() * Math.PI * 2
            };
            coin.mesh.position.set(LANES[lane], coin.initialY, -80 + zOffset);
            coins.push(coin);
            scene.add(coin.mesh);
        }
        function spawnCoins() {
            const lane = Math.floor(Math.random() * 3);
            const length = Math.floor(Math.random() * 5) + 4;
            for (let i = 0; i < length; i++) {
                createCoin(lane, i * -2.5);
            }
        }

        // --- ENVIRONMENT ---
        function createCloud() {
            const cloudGeo = new THREE.SphereGeometry(Math.random() * 3 + 2, 8, 8);
            const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const cloud = new THREE.Mesh(cloudGeo, cloudMat);
            cloud.position.set(
                (Math.random() - 0.5) * 100,
                Math.random() * 10 + 20,
                -150 - Math.random() * 100
            );
            clouds.push(cloud);
            scene.add(cloud);
        }
        
        function createTree() {
            const tree = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 4, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2;
            trunk.castShadow = true;
            tree.add(trunk);
            const leavesGeo = new THREE.ConeGeometry(2, 4, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2E8B57 });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 5;
            leaves.castShadow = true;
            tree.add(leaves);
            const side = Math.random() > 0.5 ? 1 : -1;
            tree.position.set(
                side * (LANE_WIDTH * 2.5 + Math.random() * 15),
                0,
                -150 - Math.random() * 100
            );
            trees.push(tree);
            scene.add(tree);
        }

        function createBuilding() {
            const building = new THREE.Group();
            const buildingHeight = Math.random() * 30 + 15;
            const buildingWidth = Math.random() * 8 + 8;
            const buildingDepth = Math.random() * 8 + 8;
            const buildingColor = new THREE.Color().setHSL(Math.random(), 0.1, 0.5);

            const buildingGeo = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
            const buildingMat = new THREE.MeshStandardMaterial({ color: buildingColor });
            const mainBlock = new THREE.Mesh(buildingGeo, buildingMat);
            mainBlock.castShadow = true;
            mainBlock.receiveShadow = true;
            mainBlock.position.y = buildingHeight / 2;
            building.add(mainBlock);

            const windowGeo = new THREE.PlaneGeometry(0.8, 1.2);
            const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffd1 });
            for (let y = 2; y < buildingHeight - 2; y += 3) {
                for (let x = -buildingWidth / 2 + 1; x < buildingWidth / 2 - 1; x += 2) {
                    const window = new THREE.Mesh(windowGeo, windowMat);
                    window.position.set(x, y, buildingDepth / 2 + 0.01);
                    building.add(window);
                }
            }

            const side = Math.random() > 0.5 ? 1 : -1;
            building.position.set(
                side * (LANE_WIDTH * 3 + Math.random() * 20),
                0,
                -150 - Math.random() * 100
            );
            buildings.push(building);
            scene.add(building);
        }

        function createVehicle() {
            const vehicle = new THREE.Group();
            const vehicleColors = [0x95a5a6, 0x34495e, 0x2c3e50, 0x7f8c8d];
            const carColor = vehicleColors[Math.floor(Math.random() * vehicleColors.length)];

            const bodyGeo = new THREE.BoxGeometry(3, 1.5, 6);
            const bodyMat = new THREE.MeshStandardMaterial({ color: carColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            body.receiveShadow = true;
            vehicle.add(body);

            const cabinGeo = new THREE.BoxGeometry(2.8, 1.2, 3);
            const cabin = new THREE.Mesh(cabinGeo, bodyMat);
            cabin.position.set(0, 1.35, -0.5);
            cabin.castShadow = true;
            cabin.receiveShadow = true;
            vehicle.add(cabin);

            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheelPositions = [ { x: -1.5, y: -0.25, z: 2 }, { x: 1.5, y: -0.25, z: 2 }, { x: -1.5, y: -0.25, z: -2 }, { x: 1.5, y: -0.25, z: -2 } ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                vehicle.add(wheel);
            });

            const side = Math.random() > 0.5 ? 1 : -1;
            vehicle.position.set( side * (LANE_WIDTH * 5 + Math.random() * 5), 0.75, -150 - Math.random() * 100 );
            vehicle.userData.speed = gameSpeed * (Math.random() * 0.2 + 0.1);
            vehicles.push(vehicle);
            scene.add(vehicle);
        }
        
        function createPowerLine() {
            const powerLine = new THREE.Group();
            const poleHeight = 20;
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, poleHeight, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = poleHeight / 2;
            powerLine.add(pole);

            const crossArmGeo = new THREE.BoxGeometry(4, 0.3, 0.3);
            const crossArm = new THREE.Mesh(crossArmGeo, poleMat);
            crossArm.position.y = poleHeight - 2;
            powerLine.add(crossArm);

            const side = Math.random() > 0.5 ? 1 : -1;
            const xPos = side * (LANE_WIDTH * 2.2);
            powerLine.position.set(xPos, 0, -150 - Math.random() * 100);
            
            const cableMat = new THREE.LineBasicMaterial({ color: 0x000000 });
            for (let i = -1.5; i <= 1.5; i+= 1.5) {
                const startPoint = new THREE.Vector3(i, poleHeight - 2, 0);
                const endPoint = new THREE.Vector3(i, poleHeight - 2, -80);
                const midPoint = startPoint.clone().lerp(endPoint, 0.5).add(new THREE.Vector3(0, -3, 0));
                
                const curve = new THREE.CatmullRomCurve3([startPoint, midPoint, endPoint]);
                const points = curve.getPoints(20);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const cable = new THREE.Line(geometry, cableMat);
                powerLine.add(cable);
            }
            
            powerLines.push(powerLine);
            scene.add(powerLine);
        }

        // --- PARTICLE EFFECT ---
        function createParticles(position) {
            const particleCount = 10;
            const particleGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                particle.lifespan = 1.0;
                activeParticles.push(particle);
                scene.add(particle);
            }
        }

        // --- GAME LOGIC ---
        function init() {
            isGameOver = false;
            isPaused = false;
            score = 0;
            gameSpeed = 0.3;
            currentLane = 1;

            [player, ...obstacles, ...trackSegments, ...coins, ...clouds, ...trees, ...buildings, ...vehicles, ...powerLines, ...activeParticles].forEach(obj => {
                if (obj) scene.remove(obj.mesh || obj);
            });

            obstacles.length = 0;
            trackSegments.length = 0;
            coins.length = 0;
            clouds.length = 0;
            trees.length = 0;
            buildings.length = 0;
            vehicles.length = 0;
            powerLines.length = 0;
            activeParticles.length = 0;

            player = createPlayer();
            scene.add(player);

            for (let i = 0; i < 5; i++) createTrackSegment(i * -40, i);
            for (let i = 0; i < 10; i++) createCloud();
            for (let i = 0; i < 8; i++) createTree();
            for (let i = 0; i < 8; i++) createBuilding();
            for (let i = 0; i < 5; i++) createVehicle();
            for (let i = 0; i < 3; i++) createPowerLine();
            
            scoreElement.textContent = 'Score: 0';
            scoreElement.style.display = 'block';
            gameOverScreen.style.display = 'none';
            gameOverScreen.classList.remove('active');
            pauseScreen.style.display = 'none';
            countdownScreen.style.display = 'none';
            pauseButton.style.display = 'flex';
            pauseIcon.style.display = 'block';
            playIcon.style.display = 'none';
        }

        function updatePlayer(elapsedTime) {
            const targetX = LANES[currentLane];
            player.position.x += (targetX - player.position.x) * PLAYER_SPEED;
            
            if (isJumping) {
                player.position.y += jumpVelocity;
                jumpVelocity += GRAVITY;
                if (player.position.y <= 0) {
                    player.position.y = 0;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }

            // Player Animation
            if (isRolling) {
                playerModel.rotation.x = 1.5;
                playerModel.position.y = 0.5;
                // FIX: Adjust collider for roll
                playerCollider.scale.y = 0.5;
                playerCollider.position.y = 0.875; // Half of the original y position
            } else {
                playerModel.rotation.x = 0;
                playerModel.position.y = 0;
                // FIX: Reset collider
                playerCollider.scale.y = 1.0;
                playerCollider.position.y = 1.75;
                
                if (isJumping) {
                    leftArm.rotation.x = -Math.PI / 2;
                    rightArm.rotation.x = -Math.PI / 2;
                    leftLeg.rotation.x = Math.PI / 2;
                    rightLeg.rotation.x = Math.PI / 2;
                } else {
                    const runCycle = elapsedTime * (gameSpeed * 30);
                    leftArm.rotation.x = Math.sin(runCycle) * 0.8;
                    rightArm.rotation.x = -Math.sin(runCycle) * 0.8;
                    leftLeg.rotation.x = -Math.sin(runCycle) * 0.8;
                    rightLeg.rotation.x = Math.sin(runCycle) * 0.8;
                }
            }
        }
        
        function checkInteractions() {
            const playerBox = new THREE.Box3().setFromObject(playerCollider);
            for (const obstacle of obstacles) {
                obstacle.collider.setFromObject(obstacle.mesh);
                if (playerBox.intersectsBox(obstacle.collider)) {
                    gameOver();
                    return;
                }
            }
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.collider.setFromObject(coin.mesh);
                if (playerBox.intersectsBox(coin.collider)) {
                    score += 10;
                    createParticles(coin.mesh.position);
                    scene.remove(coin.mesh);
                    coins.splice(i, 1);
                }
            }
        }

        function animateFinalScore(targetScore) {
            let currentScore = 0;
            if (targetScore === 0) {
                finalScoreElement.textContent = `Your Score: 0`;
                return;
            }
            const increment = Math.max(1, Math.ceil(targetScore / 100));
            const interval = setInterval(() => {
                currentScore += increment;
                if (currentScore >= targetScore) {
                    currentScore = targetScore;
                    clearInterval(interval);
                }
                finalScoreElement.textContent = `Your Score: ${currentScore}`;
            }, 10);
        }

        function gameOver() {
            isGameOver = true;
            gameSpeed = 0;
            gameOverScreen.style.display = 'flex';
            setTimeout(() => gameOverScreen.classList.add('active'), 10);
            animateFinalScore(Math.floor(score));
            pauseButton.style.display = 'none';
        }

        function startCountdown() {
            pauseScreen.style.display = 'none';
            countdownScreen.style.display = 'flex';
            let count = 3;

            function doCount() {
                if (count > 0) {
                    countdownNumber.textContent = count;
                    countdownNumber.classList.remove('animate');
                    void countdownNumber.offsetWidth;
                    countdownNumber.classList.add('animate');
                    count--;
                    setTimeout(doCount, 1000);
                } else {
                    countdownScreen.style.display = 'none';
                    isPaused = false;
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'block';
                    animate();
                }
            }
            doCount();
        }

        function togglePause() {
            if (isGameOver) return;
            if (!isPaused) {
                isPaused = true;
                pauseScreen.style.display = 'flex';
                pauseIcon.style.display = 'none';
                playIcon.style.display = 'block';
            } else {
                startCountdown();
            }
        }

        // --- CONTROLS ---
        function handleKeyDown(event) {
            if (isGameOver) return;
            if (event.code === 'KeyP') {
                togglePause();
                return;
            }
            if (isPaused) return;
            switch (event.code) {
                case 'ArrowLeft': case 'KeyA': if (currentLane > 0) currentLane--; break;
                case 'ArrowRight': case 'KeyD': if (currentLane < 2) currentLane++; break;
                case 'ArrowUp': case 'KeyW':
                    if (!isJumping && !isRolling) {
                        isJumping = true;
                        jumpVelocity = JUMP_FORCE;
                    }
                    break;
                case 'ArrowDown': case 'KeyS':
                    if (!isJumping && !isRolling) {
                        isRolling = true;
                        clearTimeout(rollTimeout);
                        rollTimeout = setTimeout(() => { isRolling = false; }, 800);
                    }
                    break;
            }
        }
        let touchStartX = 0, touchStartY = 0;
        function handleTouchStart(event) {
            if (isGameOver || isPaused) return;
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }
        function handleTouchEnd(event) {
            if (isGameOver || isPaused) return;
            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 30 && currentLane < 2) currentLane++;
                else if (deltaX < -30 && currentLane > 0) currentLane--;
            } else {
                if (deltaY < -30 && !isJumping && !isRolling) {
                    isJumping = true;
                    jumpVelocity = JUMP_FORCE;
                } else if (deltaY > 30 && !isJumping && !isRolling) {
                    isRolling = true;
                    clearTimeout(rollTimeout);
                    rollTimeout = setTimeout(() => { isRolling = false; }, 800);
                }
            }
        }
        
        // --- ANIMATION LOOP ---
        let clock = new THREE.Clock();
        let obstacleSpawnTimer = 0;
        let coinSpawnTimer = 0;
        function animate() {
            if (isGameOver || isPaused) return;
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            updatePlayer(elapsedTime);
            
            [...trackSegments, ...obstacles, ...coins, ...clouds, ...trees, ...buildings, ...vehicles, ...powerLines, ...activeParticles].forEach(obj => {
                const item = obj.mesh || obj;
                let speed = gameSpeed;
                if (item.userData && item.userData.speed) {
                    speed += item.userData.speed;
                }
                item.position.z += speed;
            });

            coins.forEach(coin => {
                coin.mesh.rotation.z += delta * 2;
                coin.mesh.position.y = coin.initialY + Math.sin(elapsedTime * 5 + coin.bobOffset) * 0.25;
            });

            for(let i = activeParticles.length - 1; i >= 0; i--) {
                const particle = activeParticles[i];
                particle.position.add(particle.velocity);
                particle.lifespan -= delta * 2;
                if (particle.lifespan <= 0) {
                    scene.remove(particle);
                    activeParticles.splice(i, 1);
                }
            }
            
            // Manage environment
            if (trackSegments.length > 0 && trackSegments[0].position.z > camera.position.z + 20) {
                scene.remove(trackSegments.shift());
                createTrackSegment(trackSegments[trackSegments.length - 1].position.z - 40, trackSegments.length);
            }
            if (obstacles.length > 0 && obstacles[0].mesh.position.z > camera.position.z + 20) {
                scene.remove(obstacles.shift().mesh);
            }
            if (coins.length > 0 && coins[0].mesh.position.z > camera.position.z + 20) {
                scene.remove(coins.shift().mesh);
            }
            if (clouds.length > 0 && clouds[0].position.z > camera.position.z + 20) {
                scene.remove(clouds.shift());
                createCloud();
            }
            if (trees.length > 0 && trees[0].position.z > camera.position.z + 20) {
                scene.remove(trees.shift());
                createTree();
            }
            if (buildings.length > 0 && buildings[0].position.z > camera.position.z + 20) {
                scene.remove(buildings.shift());
                createBuilding();
            }
            if (vehicles.length > 0 && vehicles[0].position.z > camera.position.z + 20) {
                scene.remove(vehicles.shift());
                createVehicle();
            }
            if (powerLines.length > 0 && powerLines[0].position.z > camera.position.z + 20) {
                scene.remove(powerLines.shift());
                createPowerLine();
            }


            obstacleSpawnTimer += gameSpeed;
            coinSpawnTimer += gameSpeed;
            if (obstacleSpawnTimer > 120) { obstacleSpawnTimer = 0; spawnObstacles(); }
            if (coinSpawnTimer > 80) { coinSpawnTimer = 0; spawnCoins(); }

            checkInteractions();

            scoreElement.textContent = `Score: ${Math.floor(score)}`;
            gameSpeed += 0.0001;

            renderer.render(scene, camera);
        }

        // --- EVENT LISTENERS ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function startGame() {
            startScreen.style.display = 'none';
            init();
            animate();
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.remove('active');
            startGame();
        });
        pauseButton.addEventListener('click', togglePause);
        document.addEventListener('keydown', handleKeyDown);
        renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });

        // --- INITIAL RENDER (NO ANIMATION) ---
        window.onload = () => {
            renderer.render(scene, camera);
        };
    </script>
</body>
</html>
